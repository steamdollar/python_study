
# Cpu-Bound task
CPU의 속도가 작업의 속도를 제한하는 중요한 요소인 작업입니다. 즉, 작업이 디스크나 네트워크에 대한 읽기 또는 쓰기와 같은 I/O를 기다리는 대신 대부분의 시간을 CPU 사용(계산 수행)에 소비한다는 의미입니다. CPU 바운드 작업의 예로는 3D 애니메이션 렌더링, 대규모 데이터 세트에 대한 복잡한 계산 수행, 머신 러닝 모델 실행 등을 들 수 있습니다.

# I/O-Bound task
디스크 또는 네트워크와 같은 I/O 하위 시스템의 속도가 작업의 속도를 제한하는 중요한 요소인 작업입니다. 즉, 작업은 CPU를 사용하는 대신 I/O 작업이 완료될 때까지 기다리는 데 대부분의 시간을 소비합니다. I/O 바운드 작업의 예로는 디스크의 파일 읽기 또는 쓰기, 네트워크를 통한 데이터 송수신, 사용자와의 상호 작용 등이 있습니다.

# 
CPU 바운드 작업과 I/O 바운드 작업의 차이는 동시성 및 병렬 처리를 위해 코드를 구성하는 방식에 큰 영향을 미칠 수 있습니다. 작업이 I/O에 바인딩된 경우 스레드 또는 비동기 I/O를 사용하여 I/O가 완료되기를 기다리는 동안 작업을 계속 수행할 수 있도록 함으로써 성능을 향상시킬 수 있습니다. 그러나 작업이 CPU에 바인딩된 경우, 더 빠르게 실행할 수 있는 유일한 방법은 여러 프로세스 또는 여러 컴퓨터를 사용하여 CPU 부하를 분산하는 것일 수 있습니다.

#
특히 파이썬에서 글로벌 인터프리터 잠금(GIL)은 단일 프로세스 내에서 한 번에 하나의 스레드만 파이썬 바이트코드를 실행할 수 있다는 것을 의미합니다. 따라서 CPU에 바인딩된 작업의 경우 여러 스레드를 사용해도 실제로 여러 CPU를 사용하여 작업을 더 빠르게 완료할 수 없습니다. 그러나 I/O 바인딩 작업의 경우 스레드는 여전히 유용할 수 있습니다. 한 스레드가 I/O가 완료되기를 기다리는 동안 다른 스레드가 계속 실행될 수 있기 때문입니다.

그렇기 때문에 Python에서 CPU에 바인딩된 작업의 경우 스레드 대신 (멀티프로세싱 모듈을 통해) 프로세스를 사용하는 경우가 많습니다. 각 프로세스에는 고유한 Python 인터프리터와 고유한 GIL이 있으므로 서로 다른 CPU에서 실제로 병렬로 실행할 수 있습니다.

간단히 말해, 태스크가 CPU에 바인딩되어 있다는 것은 사용 가능한 경우 더 많은 CPU 전력을 사용할 수 있다는 뜻입니다. 작업이 I/O에 바인딩되어 있다는 것은 I/O를 대기 중이고 CPU가 유휴 상태라는 뜻입니다.